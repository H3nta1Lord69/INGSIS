Algoritmo Red_monocapa_sigmoide_simetrico
	//funsion de salida sigmoide simetrico
	Definir w,b,p Como Real
	escribir ("escriba el numero de entradas")
	leer ne // siendo ne = No. entradas
	escribir ("escriba el numero de posibilidades")
	leer np // siendo np= No.posibilidades que se refiere a las combinaciones que pueden tener las entradas
	escribir ("defina el numero de neuronas")
	leer nn //numero de neuronas
	Dimension w[ne]
	Dimension p[np,ne]
	Dimension a[np,nn]
	Dimension se[np,nn]
	//ingreso de valores al azar 
	Para j <- 1 Hasta ne Con Paso 1 Hacer
		w[j] <- azar(100)+1
	Fin Para
	b <- azar(100)+1
	// ingreso de valores de entrada P
	Para J<-1 Hasta ne Hacer
		Para I<-1 Hasta np Hacer
			Escribir 'valor de entrada ',I,',para el P',J,':'
			Leer p[I,J]
		FinPara
	FinPara
	//ingreso de valores de salida deseada
	Para J<- 1 Hasta nn Hacer
		Para I<-1 Hasta np Hacer
			Escribir 'valor de SE',I,' de la neurona ',J,' :'
			Leer se[I,J] //se = salida esperada
		FinPara
	FinPara
	//valores iniciales
	e<-0
	sn <- 0
	aprendizaje<-0.01
	euler <- 2.72
	k<-0 //valor para conteo de interacciones opcional
	
	Repetir
	Para m <- 1 Hasta nn Con Paso 1 Hacer
		//se define las interacciones		
			para i <- 1 hasta np Con Paso 1 Hacer
				Para j<- 1 Hasta ne Con Paso 1 Hacer
					sn = (w[j]*p[i,j])+sn
				Fin Para
				sn= sn + b
				//funsion de salida
				Si sn >= 1 Entonces
					a[i,m] = (euler^(sn)-euler^(-sn))/(euler^(sn)+euler^(-sn))
				SiNo 
					a[i,m] = 0
				Fin Si
				sn =0 // salida neta valor inicial
				e=se[i,m]-a[i,m]
				//nuevos valores
				Para j<- 1 Hasta ne Con Paso 1 Hacer
					w[j]=w[j]+(2*aprendizaje*e*p[i,j])
				Fin Para
				b=b+(2*aprendizaje*e)
			fin para
		fin para
		k<-k+1
	Hasta Que  k=100
	//resultados 
	Para j<-1 Hasta nn Hacer
        Para I<-1 Hasta np Hacer
            Escribir 'valor de SO',I,' de la neurona ',j,' :',a[I,j]
        FinPara
	FinPara
	
	Para i<-1 Hasta ne Con Paso 1 Hacer
		Escribir 'valor peso w',i,': ',w[i]
	Fin Para
	Escribir 'valor bias b: ',b
FinAlgoritmo
